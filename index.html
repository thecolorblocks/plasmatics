<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CYMATICS</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      color: white;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <main id="cymatics"></main>
  <button id="button">start</button>
  <div>
    <input type="checkbox" id="colors" name="colors" checked />
    <label for="colors">Colors</label>
  </div>
  <script type="module">
    // OST Testing UI
    const ost = [
      "1eab87f0048147a37b3be9f0f35227c77a7b258ce37ef1cf4a0e7adb16b20f5ei0",
      "38044fd0aebd10be731c862a2cc1b4602f6bddaff789fd384e4bbf60407b26d4i0",
      "3cd97df66fd5ed0291988860aa1c2e8897b44fc168bd7b3bba5060e4a22a12dbi0",
      "56f1302d4256b752593b7a20d4412f587b6d9480b52ff2db2ffd0a92fb7199b1i0",
      "604e061375a5904badb4429ed7791bc9b337791da8d1b27b9caa6294f65bdbdfi0",
      "6f2e818ee1eccdb7e8813fa65c0488b4ceacda6b4325fc6efcc88404f14e752ei0",
      "8fcf850193bcd935a0b037c4ffd15be25786e329a09af9972d8e074b69f74c34i0",
      "a14e28ac655910d04aaf936d411e84157c2318500ad3b260dc7f2451c890ec04i0",
      "a5752e953ef6584a0260d8033f938fcf13ae327f07d0495a7379b9de7a93f512i0",
      "cfb30e9b930660b251ee7bc279da207a5545b1ac147a0e8d99f91ef699766308i0",
      "e00ba279dfd033f9de394766a2032c27339fc7d6f5fe913c6c4664543884e922i0",
      "e47f4f20f7d8729748f3e80a36b9e2d600b642880139bffb8394ead26136652ei0"
    ]
    const select = document.createElement('select')
    for (let i = 0; i < ost.length; i++) {
      const option = document.createElement('option')
      option.value = ost[i]
      option.textContent = `OST-${i+1}`
      select.appendChild(option)
    }
    document.body.appendChild(select)
    let insID = ost[11]
    let audio = 'https://ordinals.com/content/' + insID
    select.value = insID

    const colorCheckbox = document.body.querySelector('input#colors')

    import * as fflate from 'https://ordinals.com/content/f815bd5c566c6e46de5cdb6ccb3a7043c63deeba61f4234baea84b602b0d4440i0'

    const b64data = await (await fetch('http://ordinals.com/content/255ce0c5a0d8aca39510da72e604ef8837519028827ba7b7f723b7489f3ec3a4i0')).text()
    const code = fflate.strFromU8(
      fflate.decompressSync(
        fflate.strToU8(
          atob(b64data), true
        )
      )
    )
    const script = document.createElement('script')
    script.innerHTML = code
    document.head.appendChild(script)

    const audioSetup = () => {
      const audioCtx = new AudioContext()
      const analyser = audioCtx.createAnalyser()
      const button = document.querySelector('#button')
      const audioElement = new Audio(audio)
      audioElement.crossOrigin = "anonymous"
      audioElement.type = 'audio/mp3'
      audioElement.loop = false
      const sourceNode = audioCtx.createMediaElementSource(audioElement)
      
      sourceNode.connect(analyser)
      analyser.connect(audioCtx.destination)

      analyser.fftSize = 2048
      analyser.smoothingTimeConstant = 0.5
      let frequencyData = new Uint8Array(analyser.frequencyBinCount)
      let timeDomainData = new Uint8Array(analyser.frequencyBinCount)
      let bufferLength = analyser.frequencyBinCount
      let frequencyBinWidth = audioCtx.sampleRate / analyser.fftSize

      return [audioElement, audioCtx, analyser, frequencyData, timeDomainData, bufferLength, frequencyBinWidth]
    }

    let audioElement, audioCtx, analyser, frequencyData, timeDomainData, bufferLength, frequencyBinWidth, amplitude

    let particles
    let A = 0.02
    let minWalk = 0.005

    const getN = () => {
      return parseInt(insID[0], 16) % 8 + 1
    }

    const getA = () => {
      return parseInt(insID[1], 16) % 4 + 1
    }

    const getB = () => {
      return parseInt(insID[2], 16) % 4 + 1
    }

    const getIsColor = () => {
      return colorCheckbox.checked
    }

    const getColorSeed = () => {
      return parseInt(insID.slice(4, 6), 16) % 16
    }

    const colorWheel16 = (initialAngle) => {
      const nColors = 16
      const degree = params.HSBFactor / nColors
      let colors = []
      colorMode(HSB, params.HSBFactor)
      for (let i = 0; i < nColors; i++) {
        let c = color(initialAngle + i*degree, params.saturation, params.brightness)
        colors.push(c)
      }
      return colors
    }

    const params = {
      nParticles: 3000,
      canvasSize: [600, 600],
      m0: 0,
      m1: 0,
      m2: 0,
      n: getN,
      a: getA,
      b: getB,
      v: 0.04,
      noiseL: 1.1,
      shapeConstant: 0.006,
      shapeBaseConstant: 0,
      ampFactor: 0.00001,
      particleSizeFactor: 100,
      particleVariationL: 3,
      particleAlpha: 10,
      waitingPeriod: 3000,
      isColor: getIsColor,
      colorSeed: getColorSeed,
      HSBFactor: 255,
      HSBInitialAngle: -60,
      saturation: 255,
      brightness: 255
    }

    const pi = Math.PI

    let spectrum = []

    const aurora = ['#FF443D', '#FFF23D', '#84FF3D', '#3DFFF9', '#403DFF', '#FF3DF2']

    let colors = []

    const cymatics = (x, y, m, n) => {
      return params.a() * Math.cos(pi*n*(x-.5)) * Math.cos(pi*m*(y-.5)) + params.b() * Math.cos(pi*m*(x-.5)) * Math.cos(pi*n*(y-.5))
    }

    const complementaries = (c) => {
      let wholeAngle = params.HSBFactor
      let angle = Math.floor(wholeAngle / 6)
      let h = hue(c)
      let colors = [
        color(h, params.saturation, params.brightness),
        color((h+angle)%wholeAngle, params.saturation, params.brightness),
        color((h+angle*2)%wholeAngle, params.saturation, params.brightness)
      ]
      colors.map(c => c.setAlpha(params.particleAlpha))
      return colors
    }

    const splitComplementaries = (c) => {
      let wholeAngle = params.HSBFactor
      let angle = Math.floor(wholeAngle * 0.4)
      let h = hue(c)
      let colors = [
        color(h, params.saturation, params.brightness),
        color((h+angle)%wholeAngle, params.saturation, params.brightness),
        color((h-angle)%wholeAngle, params.saturation, params.brightness)
      ]
      colors.map(c => c.setAlpha(params.particleAlpha))
      return colors
    }

    const insHexColors = () => {
      let colors = [
        color(parseInt(insID.slice(4,6), 16), params.saturation, params.brightness),
        color(parseInt(insID.slice(6,8), 16), params.saturation, params.brightness),
        color(parseInt(insID.slice(8,10), 16), params.saturation, params.brightness),
      ]
      colors.map(c => c.setAlpha(params.particleAlpha))
      return colors
    }

    const bark = (f) => {
      return 13 * Math.atan(0.00076*f) + 3.5 * atan(Math.pow((f/7500), 2))
    }

    const mel = (f) => {
      return 2595 * Math.log10(1 + f / 700)
    }

    const centroid = (frequencyData) => {
      const sum = frequencyData.reduce((acc, value) => acc + value, 0)
      const weightedSum = frequencyData.reduce((acc, value, index) => acc + value, 0)
      return (sum === 0) ? 0 : weightedSum / sum
    }

    const barkCentroid = (frequencyData, frequencyBinWidth) => {
      const sum = frequencyData.reduce((acc, value) => acc + value, 0)
      const weightedSum = frequencyData.reduce((acc, value, index) => acc + value * index * bark(index*frequencyBinWidth), 0)
      return (sum === 0) ? 0 : weightedSum / sum
    }

    const melCentroid = (frequencyData, frequencyBinWidth) => {
      const sum = frequencyData.reduce((acc, value) => acc + value, 0)
      const weightedSum = frequencyData.reduce((acc, value, index) => acc + value * mel(index*frequencyBinWidth) * (255-index), 0)
      return (sum === 0) ? 0 : weightedSum / sum
    }

    const handleEdge = (n) => {
      if (n>=1) return 1
      if (n<=0) return 0
      return n
    }

    const initParticles = () => {
      particles = []
      for (let i = 0; i < params.nParticles; i++){
        particles[i] = new Particle()
      }
    }

    const initDOM = () => {
      let canvas = createCanvas(...params.canvasSize)
      canvas.parent('cymatics')
    }

    class Particle {

      constructor(){
        this.x = random(0, 1)
        this.y = random(0, 1)
        this.oscillation
        this.type = Math.floor(random(0, params.particleVariationL))
        this.distance

        this.updateOffsets()
      }

      // Use shader code to optimize
      move() {
        this.distance = Math.abs( cymatics(this.x, this.y, params[`m${this.type}`], params.n()) )
        this.oscillation = params.v * this.distance
        if (this.oscillation <= minWalk) this.oscillation = minWalk
        this.x += (Math.random() * (this.oscillation*2) - this.oscillation) * noise(this.distance) * params.noiseL
        this.y += (Math.random() * (this.oscillation*2) - this.oscillation) * noise(this.distance) * params.noiseL
        this.updateOffsets()
      }

      updateOffsets(){
        this.x = handleEdge(this.x)
        this.y = handleEdge(this.y)
        this.xScaled = width * this.x
        this.yScaled = height * this.y
      }

      draw(){
        if (params.isColor()) {
          stroke(colors[this.type])
          strokeWeight((1-this.distance*.5)*params.particleSizeFactor)
        } else {
          stroke('white')
          strokeWeight((1-this.distance*.5))
        }
        point(this.xScaled, this.yScaled)
      }
    }

    const resonate = () => {
      analyser.getByteFrequencyData(frequencyData)
      analyser.getByteTimeDomainData(timeDomainData)
      amplitude = timeDomainData.reduce((sum, value) => sum + value, 0) / bufferLength
      minWalk = amplitude * params.ampFactor
      let barkConstant = (barkCentroid(frequencyData, frequencyBinWidth)*params.shapeConstant) + params.shapeBaseConstant
      let melConstant = (melCentroid(frequencyData, frequencyBinWidth)*params.shapeConstant) + params.shapeBaseConstant
      let centroidConstant = (centroid(frequencyData)*params.shapeConstant) + params.shapeBaseConstant
      params.m0 = barkConstant
      params.m1 = melConstant
      params.m2 = centroidConstant
      particles.map( p => {
        p.move()
        p.draw()
      })
    }

    const resetCanvas = () => {
      background('black')
    }

    window.setup = () => {
      [audioElement, audioCtx, analyser, frequencyData, timeDomainData, bufferLength, frequencyBinWidth] = audioSetup()
      initDOM()
      initParticles()
      colorMode(HSB, 255)
      noiseSeed(99)
      spectrum = colorWheel16(params.HSBInitialAngle)
      colors = complementaries(spectrum[params.colorSeed()])
      //colors = insHexColors()
      audioElement.addEventListener('canplaythrough', () => {
        console.log('ready')
      }, false)

      audioElement.addEventListener('ended', () => {
        window.setTimeout(() => {
          audioElement.play()
        }, params.waitingPeriod)
      }, false)
    }

    window.draw = () => {
      resetCanvas()
      resonate()
    }

    const begin = () => {
      audioCtx.resume()
      audioElement.play()
    }

    button.addEventListener('click', begin, false)

    select.addEventListener('change', (event) => {
      insID = event.target.value
      audio = 'https://ordinals.com/content/' + insID
      audioElement.src = audio
      colors = complementaries(spectrum[params.colorSeed()])
      //colors = insHexColors()
    }, false)
  </script>
</body>
</html>
