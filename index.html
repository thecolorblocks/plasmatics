<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cymatics</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <main id="cymatics"></main>
  <button id="button">start</button>
  <script type="module">

    import * as fflate from 'https://ordinals.com/content/f815bd5c566c6e46de5cdb6ccb3a7043c63deeba61f4234baea84b602b0d4440i0'

    const b64data = await (await fetch('http://ordinals.com/content/255ce0c5a0d8aca39510da72e604ef8837519028827ba7b7f723b7489f3ec3a4i0')).text()
    const code = fflate.strFromU8(
      fflate.decompressSync(
        fflate.strToU8(
          atob(b64data), true
        )
      )
    )
    const script = document.createElement('script')
    script.innerHTML = code
    document.head.appendChild(script)

    const insID = '1eab87f0048147a37b3be9f0f35227c77a7b258ce37ef1cf4a0e7adb16b20f5ei0'

    const audioSetup = () => {
      //const audio = 'https://ordinals.com/content/38044fd0aebd10be731c862a2cc1b4602f6bddaff789fd384e4bbf60407b26d4i0'
      const audio = 'https://ordinals.com/content/' + insID
      const audioCtx = new AudioContext()
      const analyser = audioCtx.createAnalyser()
      const button = document.querySelector('#button')
      const audioElement = new Audio(audio)
      audioElement.crossOrigin = "anonymous"
      audioElement.type = 'audio/mp3'
      audioElement.loop = true
      const sourceNode = audioCtx.createMediaElementSource(audioElement)
      
      sourceNode.connect(analyser)
      analyser.connect(audioCtx.destination)

      analyser.fftSize = 128
      let frequencyData = new Uint8Array(analyser.frequencyBinCount)
      let bufferLength = analyser.frequencyBinCount

      return [audioElement, audioCtx, analyser, frequencyData, bufferLength]
    }

    let audioElement, audioCtx, analyser, frequencyData, bufferLength, amplitude

    let particles
    let A = 0.02
    let minWalk = 0.001

    const params = {
      nParticles: 12000,
      canvasSize: [600, 600],
      m0: 0,
      m1: 0,
      m2: 0,
      n: parseInt(insID[0], 16) % 8 + 1,
      a: parseInt(insID[1], 16) % 4 + 1,
      b: parseInt(insID[2], 16) % 4 + 1,
      v: 0.05,
      noiseL: 1,
      shapeConstant: 0.03,
      ampFactor: 0.0001
    }
    console.log(params)

    const colors = [
      'cyan',
      'purple',
      'blue'
    ]

    const pi = Math.PI

    const cymatics = (x, y, m, n) => {
      return params.a * Math.sin(pi*n*x) * Math.sin(pi*m*y) + params.b * Math.sin(pi*m*x) * Math.sin(pi*n*y)
    }

    const handleEdge = (n) => {
      if (n>=1) return 1
      if (n<=0) return 0
      return n
    }

    const initParticles = () => {
      particles = []
      for (let i = 0; i < params.nParticles; i++){
        particles[i] = new Particle()
      }
    }

    const initDOM = () => {
      let canvas = createCanvas(...params.canvasSize)
      canvas.parent('cymatics')
    }

    class Particle {

      constructor(){
        this.x = random(0, 1)
        this.y = random(0, 1)
        this.stochasticAmplitude
        this.type = Math.floor(random(0, 3))

        this.updateOffsets()
      }

      // Use shader code to optimize
      move() {
        let eq = cymatics(this.x, this.y, params[`m${this.type}`], params.n)
        this.stochasticAmplitude = params.v * Math.abs(eq)
        if (this.stochasticAmplitude <= minWalk) this.stochasticAmplitude = minWalk
        this.x += (Math.random() * (this.stochasticAmplitude*2) - this.stochasticAmplitude) * noise(this.x) * params.noiseL
        this.y += (Math.random() * (this.stochasticAmplitude*2) - this.stochasticAmplitude) * noise(this.y) * params.noiseL
        this.updateOffsets()
      }

      updateOffsets(){
        this.x = handleEdge(this.x)
        this.y = handleEdge(this.y)
        this.xScaled = width * this.x
        this.yScaled = height * this.y
      }

      draw(){
        point(this.xScaled, this.yScaled)
        //stroke(colors[this.type])
        strokeWeight(2)
      }
    }

    const resonate = () => {
      analyser.getByteFrequencyData(frequencyData)
      amplitude = frequencyData.reduce((sum, value) => sum + value, 0) / bufferLength
      minWalk = amplitude * params.ampFactor
      params.m0 = Math.ceil(frequencyData[9]*params.shapeConstant)
      params.m1 = Math.ceil(frequencyData[6]*params.shapeConstant)
      params.m2 = Math.ceil(frequencyData[3]*params.shapeConstant)
      particles.map( p => {
        p.move()
        p.draw()
      })
    }

    const resetCanvas = () => {
      background('black')
      stroke('white')
    }

    window.setup = () => {
      [audioElement, audioCtx, analyser, frequencyData, bufferLength] = audioSetup()
      initDOM()
      initParticles()
      audioElement.addEventListener('canplaythrough', () => {
        console.log('ready')
      }, false)
    }

    const begin = () => {
      audioCtx.resume()
      audioElement.play()
      window.draw = () => {
        resetCanvas()
        resonate()
      }
    }

    button.addEventListener('click', begin, false)
  </script>
</body>
</html>
